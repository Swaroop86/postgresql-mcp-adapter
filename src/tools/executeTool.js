import path from 'path';

export class ExecuteTool {
  constructor(mcpService, fileService, logger) {
    this.mcpService = mcpService;
    this.fileService = fileService;
    this.logger = logger;
  }

  getDefinition() {
    return {
      name: 'execute_postgresql_integration',
      description: 'Generate and apply PostgreSQL integration code based on database schema',
      inputSchema: {
        type: 'object',
        properties: {
          planId: {
            type: 'string',
            description: 'Plan ID from create_postgresql_integration_plan'
          },
          schema: {
            type: 'object',
            description: 'Database schema definition',
            properties: {
              tables: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    name: { type: 'string' },
                    fields: {
                      type: 'array',
                      items: {
                        type: 'object',
                        properties: {
                          name: { type: 'string' },
                          type: { type: 'string' },
                          length: { type: 'integer' },
                          primaryKey: { type: 'boolean', default: false },
                          autoIncrement: { type: 'boolean', default: false },
                          nullable: { type: 'boolean', default: true },
                          unique: { type: 'boolean', default: false },
                          defaultValue: { type: 'string' },
                          foreignKey: {
                            type: 'object',
                            properties: {
                              table: { type: 'string' },
                              column: { type: 'string' },
                              onDelete: { type: 'string', default: 'CASCADE' }
                            }
                          }
                        },
                        required: ['name', 'type']
                      }
                    }
                  },
                  required: ['name', 'fields']
                }
              }
            },
            required: ['tables']
          },
          projectPath: {
            type: 'string',
            description: 'Path to the project directory (usually current directory)',
            default: '.'
          },
          applyToProject: {
            type: 'boolean',
            description: 'Whether to automatically apply generated files to the project',
            default: true
          }
        },
        required: ['planId', 'schema']
      }
    };
  }

  async execute(args) {
    const { planId, schema, projectPath = '.', applyToProject = true } = args;

    this.logger.info(`🚀 Starting PostgreSQL integration execution`);
    this.logger.info(`📋 Plan ID: ${planId}`);
    this.logger.info(`📊 Tables to process: ${schema.tables?.length || 0}`);
    this.logger.info(`📁 Target project: ${projectPath}`);
    this.logger.info(`💾 Apply to project: ${applyToProject ? 'Yes' : 'No'}`);

    // Set the project context in FileService
    if (applyToProject) {
      this.fileService.setProjectRoot(projectPath);
      const projectInfo = await this.fileService.getProjectInfo();
      
      this.logger.info(`📂 Project root resolved to: ${projectInfo.projectRoot}`);
      this.logger.info(`📝 Project writable: ${projectInfo.isWritable ? 'Yes' : 'No'}`);
      this.logger.info(`📁 Project exists: ${projectInfo.exists ? 'Yes' : 'No'}`);

      if (!projectInfo.exists) {
        throw new Error(`Project directory does not exist: ${projectInfo.projectRoot}`);
      }

      if (!projectInfo.isWritable) {
        throw new Error(`Project directory is not writable: ${projectInfo.projectRoot}`);
      }
    }

    try {
      this.logger.info(`🔄 Phase 1: Calling Spring Boot MCP server...`);
      
      const executionData = await this.mcpService.executePlan({
        planId,
        schema,
        applyToProject: false // Let our adapter handle file application
      });

      if (executionData.status === 'error') {
        const errorMsg = executionData.error?.message || 'Unknown error from Spring Boot server';
        this.logger.error(`❌ Spring Boot server error: ${errorMsg}`);
        throw new Error(`Plan execution failed: ${errorMsg}`);
      }

      this.logger.info(`✅ Phase 1 completed - code generated by Spring Boot server`);
      this.logger.info(`📊 Generated ${this.getTotalFileCount(executionData.generatedFiles)} files`);

      // Apply files to project if requested
      let filesApplied = 0;
      if (applyToProject && executionData.generatedFiles) {
        this.logger.info(`🔄 Phase 2: Applying generated files to project...`);
        
        try {
          filesApplied = await this.fileService.applyGeneratedFiles(
            executionData.generatedFiles,
            projectPath
          );
          this.logger.info(`✅ Phase 2 completed - ${filesApplied} files applied to project`);
        } catch (error) {
          this.logger.error(`❌ Phase 2 failed: ${error.message}`);
          // Don't throw here - we still want to show the generated code even if file application failed
          filesApplied = 0;
        }
      }

      const result = {
        content: [
          {
            type: 'text',
            text: this.formatExecutionResponse(executionData, applyToProject, filesApplied, projectPath)
          }
        ]
      };

      this.logger.info(`🎉 Integration execution completed successfully`);
      return result;

    } catch (error) {
      this.logger.error(`💥 Integration execution failed: ${error.message}`);
      this.logger.error(`🔍 Error stack: ${error.stack}`);
      
      return {
        content: [
          {
            type: 'text',
            text: this.formatErrorResponse(error, planId, projectPath)
          }
        ]
      };
    }
  }

  formatExecutionResponse(executionData, applyToProject, filesApplied, projectPath) {
    const summary = executionData.summary || {};
    const validation = executionData.validation || {};
    const projectInfo = this.fileService.getProjectRoot();

    let response = `# 🎉 PostgreSQL Integration Completed Successfully!

## 📊 Execution Summary
- **Execution ID:** \`${executionData.executionId || 'N/A'}\`
- **Plan ID:** \`${executionData.planId || 'N/A'}\`
- **Tables Processed:** ${summary.tablesProcessed || 0}
- **Files Generated:** ${summary.filesGenerated || 0}
- **Dependencies Added:** ${summary.dependenciesAdded || 0}
- **Total Lines of Code:** ${summary.totalLinesOfCode || 0}
${applyToProject ? `- **Files Applied to Project:** ${filesApplied}` : ''}

## 📂 Project Information
- **Project Directory:** \`${projectInfo}\`
- **Files Applied:** ${applyToProject ? (filesApplied > 0 ? '✅ Yes' : '❌ Failed') : '➖ Not requested'}

## 📁 Generated Components

${executionData.generatedFiles?.map(category => 
  `### ${category.category}
${category.files?.map(file => 
  `- **${path.basename(file.path)}** (${file.size || 0} lines)
  - 📂 Path: \`${file.path}\`
  - 🔧 Action: ${file.action}${file.action === 'modify' ? `
  - 📝 Changes: ${this.formatChanges(file.changes)}` : ''}`
).join('\n') || ''}`
).join('\n\n') || 'No files generated'}`;

    // Add validation results if available
    if (validation.compilationCheck || validation.dependencyCheck) {
      response += `\n\n## ✅ Quality Validation
- **Compilation Check:** ${validation.compilationCheck === 'passed' ? '✅' : '❌'} ${validation.compilationCheck || 'Not checked'}
- **Dependency Check:** ${validation.dependencyCheck === 'passed' ? '✅' : '❌'} ${validation.dependencyCheck || 'Not checked'}
- **Naming Conventions:** ${validation.namingConventions === 'passed' ? '✅' : '❌'} ${validation.namingConventions || 'Not checked'}`;

      if (validation.codeQuality?.score) {
        response += `\n- **Code Quality Score:** ${validation.codeQuality.score}/100 ${this.getScoreEmoji(validation.codeQuality.score)}`;
      }
    }

    // Add next steps
    if (executionData.postExecutionSteps && executionData.postExecutionSteps.length > 0) {
      response += `\n\n## 🚀 Next Steps Required

${executionData.postExecutionSteps.map(step => 
  `${step.step}. **${step.action}**${step.required ? ' 🔴 (Required)' : ' 🟡 (Optional)'}
   ${step.description}${step.resource ? `
   📖 **Resource:** ${step.resource}` : ''}`
).join('\n\n')}`;
    }

    // Add status message
    response += `\n\n---`;
    if (applyToProject && filesApplied > 0) {
      response += `\n🎯 **Success!** Files have been automatically applied to your project at:
\`${projectInfo}\`

You can now:
1. 🔄 Restart your Spring Boot application
2. 📊 Check the generated files in your IDE
3. 🧪 Test the new API endpoints`;
    } else if (applyToProject && filesApplied === 0) {
      response += `\n⚠️ **Files generated but not applied to project.**
The code was generated successfully but couldn't be written to your project directory.

**Troubleshooting:**
1. Check if Cursor is opened in the correct project directory
2. Verify the project directory is writable
3. Check the MCP adapter logs for detailed error messages`;
    } else {
      response += `\n📋 **Files generated but not applied.**
Set \`applyToProject: true\` to automatically apply files to your project.`;
    }

    if (executionData.metadata?.executionTime) {
      response += `\n\n⏱️ *Execution Time: ${executionData.metadata.executionTime}*`;
    }

    return response;
  }

  formatErrorResponse(error, planId, projectPath) {
    const projectInfo = this.fileService.getProjectRoot();
    
    return `# ❌ PostgreSQL Integration Failed

## 🚨 Error Details
- **Plan ID:** \`${planId}\`
- **Target Project:** \`${projectInfo}\`
- **Error:** ${error.message}

## 🔧 Troubleshooting Steps

1. **Check MCP Server Connection**
   - Ensure your Spring Boot MCP server is running
   - Test: \`curl http://localhost:8080/mcp/health\`

2. **Verify Project Setup**
   - Make sure Cursor is opened in your Spring Boot project directory
   - Check that the project has a \`pom.xml\` file

3. **Check Plan Status**
   - The plan might have expired (plans last 10 minutes)
   - Create a new plan if needed

4. **Review Logs**
   - Check the MCP adapter terminal for detailed error messages
   - Check the Spring Boot server logs

## 🔄 Try Again
1. Create a new integration plan
2. Execute with a fresh plan ID
3. Ensure your project directory is accessible

---
💡 **Need help?** Check the logs in your MCP adapter terminal for more details.`;
  }

  formatChanges(changes) {
    if (!changes) return '';
    
    if (changes.added && Array.isArray(changes.added)) {
      return changes.added.join(', ');
    }
    
    return JSON.stringify(changes);
  }

  getScoreEmoji(score) {
    if (score >= 90) return '🟢';
    if (score >= 70) return '🟡';
    return '🔴';
  }

  getTotalFileCount(generatedFiles) {
    if (!generatedFiles) return 0;
    return generatedFiles.reduce((total, category) => total + (category.files?.length || 0), 0);
  }
}